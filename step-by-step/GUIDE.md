# üìö Step-by-Step Tutorial: Mastering caster-generator

Welcome to the comprehensive tutorial for `caster-generator`! This guide will take you from zero to hero, covering every feature of the tool through hands-on examples.

## Prerequisites

- Go 1.21+ installed
- Basic Go knowledge (structs, packages, types)
- The caster-generator binary built (`make build` from repo root)

## Tutorial Structure

Each step has:
1. **A shell script** (`stepN.sh`) you can run
2. **Explanation** in this guide
3. **Generated files** in `step-by-step/stages/stepN/`

Run any step:
```bash
cd step-by-step
./stepN.sh
```

Or run all steps sequentially:
```bash
cd step-by-step
./run_all.sh
```

---

## üéØ Learning Path

| Step | Topic                   | Description                                     |
|------|-------------------------|-------------------------------------------------|
| 1    | Analyze                 | Explore packages and discover struct types      |
| 2    | Suggest                 | Generate your first mapping suggestion          |
| 3    | Generate                | Create caster code from a mapping               |
| 4    | 121 Mappings            | Simple field renames with `121` shorthand       |
| 5    | Fields Section          | Explicit field mappings with full control       |
| 6    | Ignore & Auto           | Skip fields and understand auto-matching        |
| 7    | Transforms Basics       | Handle type mismatches with transform functions |
| 8    | Multi-Source Transforms | Combine multiple fields into one (N:1)          |
| 9    | Transform Stubs         | Auto-generate transform function stubs          |
| 10   | Nested Structs          | Map complex nested types with dive hints        |
| 11   | Collections             | Slices, arrays, and maps                        |
| 12   | Pointers & Deep Paths   | Pointer handling and deep field access          |
| 13   | Recursive Types         | Self-referential struct mapping                 |
| 14   | Context Passing         | `requires` and `extra` for parent-child data    |
| 15   | Virtual Types           | Generate target types on-the-fly                |
| 16   | Cross-Package Virtual   | Generate types in different packages            |
| 17   | Check Command           | Validate mappings for CI/CD                     |
| 18   | Full Workflow           | Complete real-world scenario                    |

---

## Step 1: Analyze ‚Äî Exploring Your Types

**Goal:** Learn to inspect packages and discover available struct types.

The `analyze` command is your starting point. It shows you what structs exist in your packages.

### Basic Usage

```bash
# Analyze all packages in current directory tree
caster-generator analyze -pkg ./...

# Analyze specific packages
caster-generator analyze -pkg ./store -pkg ./warehouse

# Filter to show only a specific type
caster-generator analyze -pkg ./store -type Order

# Verbose mode shows field tags
caster-generator analyze -pkg ./store -verbose
```

### What You'll See

```
Package: store
  Type: Product
    - ID (int64)
    - SKU (string)
    - Name (string)
    - PriceCents (int64)
    ...
  Type: Order
    - ID (int64)
    - CustomerID (int64)
    - Items ([]OrderItem)
    ...
```

### Run the Example

```bash
./step1.sh
```

This will analyze the `store` and `warehouse` packages included in this repo.

---

## Step 2: Suggest ‚Äî Getting Smart Mapping Suggestions

**Goal:** Generate an initial YAML mapping file automatically.

The `suggest` command uses intelligent matching to propose field mappings.

### Basic Usage

```bash
# Generate suggestion for a type pair
caster-generator suggest \
  -from store.Product \
  -to warehouse.Product \
  -out mapping.yaml
```

### Understanding the Output

```yaml
version: "1"
mappings:
  - source: caster-generator/store.Product
    target: caster-generator/warehouse.Product
    auto:
      - source: ID
        target: ID
        # confidence: 0.95
      - source: Name
        target: Name
        # confidence: 0.92
    # unmapped targets:
    #   - Weight (no direct match)
```

### Tuning Suggestions

```bash
# Lower threshold catches more matches (may include false positives)
caster-generator suggest -from store.Product -to warehouse.Product \
  -min-confidence 0.5 -out mapping.yaml

# Higher threshold is stricter (fewer but more reliable matches)
caster-generator suggest -from store.Product -to warehouse.Product \
  -min-confidence 0.9 -out mapping.yaml
```

### Run the Example

```bash
./step2.sh
```

---

## Step 3: Generate ‚Äî Creating Caster Code

**Goal:** Generate actual Go code from your mapping file.

### Basic Usage

```bash
caster-generator gen \
  -mapping mapping.yaml \
  -out ./generated \
  -package casters
```

### Generated Output

```go
// Code generated by caster-generator. DO NOT EDIT.
package casters

func StoreProductToWarehouseProduct(in store.Product) warehouse.Product {
    return warehouse.Product{
        ID:    in.ID,
        Name:  in.Name,
        // ...
    }
}
```

### Options

| Flag                        | Description                               |
|-----------------------------|-------------------------------------------|
| `-out <dir>`                | Output directory (default: `./generated`) |
| `-package <name>`           | Package name (default: `casters`)         |
| `-strict`                   | Fail if any target field is unmapped      |
| `-write-suggestions <file>` | Write suggested mappings for review       |

### Run the Example

```bash
./step3.sh
```

---

## Step 4: 121 Mappings ‚Äî Simple Field Renames

**Goal:** Use the `121` shorthand for direct field renames.

The `121` section provides a compact way to express simple one-to-one field mappings.

### YAML Syntax

```yaml
mappings:
  - source: store.Product
    target: warehouse.Product
    "121":
      # source_field: target_field
      ID: ID
      SKU: SKU
      Name: Name
      PriceCents: Price      # Rename: PriceCents ‚Üí Price
      Inventory: Stock       # Rename: Inventory ‚Üí Stock
```

### When to Use `121`

- ‚úÖ Same types, just different names
- ‚úÖ Exact type matches (string‚Üístring, int‚Üíint)
- ‚úÖ Quick, readable mappings

### When NOT to Use `121`

- ‚ùå Type conversions (use `fields` with `transform`)
- ‚ùå Complex logic (use `fields`)

### Run the Example

```bash
./step4.sh
```

---

## Step 5: Fields Section ‚Äî Full Control

**Goal:** Use the `fields` section for explicit, detailed mappings.

The `fields` section gives you complete control over how each field is mapped.

### Basic Field Mapping

```yaml
fields:
  # Simple mapping (same as 121)
  - source: Name
    target: ProductName

  # With transform function
  - source: PriceCents
    target: PriceUSD
    transform: CentsToDollars

  # Default value (no source)
  - target: Status
    default: "active"
```

### Priority Order

When fields appear in multiple sections, priority is:
1. `121` (highest)
2. `fields`
3. `ignore`
4. `auto` (lowest)

### Run the Example

```bash
./step5.sh
```

---

## Step 6: Ignore & Auto ‚Äî Controlling the Mapper

**Goal:** Skip unwanted fields and understand auto-matching.

### Ignore Section

Use `ignore` to tell the generator to skip certain target fields:

```yaml
mappings:
  - source: store.Order
    target: warehouse.Order
    ignore:
      - InternalID      # Database-generated, don't map
      - CreatedAt       # Set by ORM
      - UpdatedAt       # Set by ORM
```

### Auto Section

The `auto` section contains fields matched automatically by the `suggest` command:

```yaml
auto:
  - source: Email
    target: Email
    # confidence: 0.98
  - source: FullName
    target: Name
    # confidence: 0.75
```

You typically don't write `auto` manually ‚Äî let `suggest` fill it in.

### Run the Example

```bash
./step6.sh
```

---

## Step 7: Transforms Basics ‚Äî Handling Type Mismatches

**Goal:** Use transform functions when source and target types differ.

### When You Need Transforms

- `float64` (dollars) ‚Üí `int64` (cents)
- `string` ‚Üí `int`
- `string` (date) ‚Üí `time.Time`
- `string` ("Y"/"N") ‚Üí `bool`

### Declaring Transforms

```yaml
transforms:
  - name: DollarsToCents
    signature: "func(float64) int64"
  - name: ParseDate
    signature: "func(string) time.Time"

mappings:
  - source: store.Product
    target: warehouse.Product
    fields:
      - source: PriceUSD
        target: PriceCents
        transform: DollarsToCents
```

### Implementing Transforms

Create a Go file with your transform functions:

```go
package transforms

// DollarsToCents converts a dollar amount to cents.
func DollarsToCents(dollars float64) int64 {
    return int64(dollars * 100)
}

// ParseDate parses an ISO date string.
func ParseDate(s string) time.Time {
    t, _ := time.Parse(time.RFC3339, s)
    return t
}
```

### Auto-Generating Missing Transforms

If you map incompatible types (like `string` to `uint`) without providing a transform, the `suggest` command can auto-generate placeholder functions for you.

1. **Suggest identifies the mismatch** and adds a `TODO_` transform to your mapping:
   ```yaml
   fields:
     - source: ProductID
       target: ID
       transform: TODO_ProductIDToID
   ```

2. **Gen creates the stub** in `missing_transforms.go`:
   ```go
   func TODO_ProductIDToID(v0 string) uint {
       panic("transform TODO_ProductIDToID not implemented")
   }
   ```

This gives you a clear compilation target: simply replace the panic with your conversion logic.

### Run the Example

```bash
./step7.sh
```

---

## Step 8: Multi-Source Transforms ‚Äî Combining Fields (N:1)

**Goal:** Map multiple source fields to a single target field.

### YAML Syntax

```yaml
fields:
  # Combine FirstName and LastName into FullName
  - source: [FirstName, LastName]
    target: FullName
    transform: ConcatNames
```

### Transform Function

```go
// ConcatNames combines first and last name.
func ConcatNames(first, last string) string {
    return first + " " + last
}
```

### Generated Code

```go
out.FullName = ConcatNames(in.FirstName, in.LastName)
```

### Run the Example

```bash
./step8.sh
```

---

## Step 9: Transform Stubs ‚Äî Auto-Generated Placeholders

**Goal:** Let the generator create stub functions for missing transforms.

When you use transforms that don't exist yet, the generator creates stubs in `missing_transforms.go`:

```go
// Code generated by caster-generator. DO NOT EDIT.
// Implement these functions and move to your own file.

package casters

func DollarsToCents(v0 float64) int64 {
    panic("transform DollarsToCents not implemented")
}
```

### Workflow

1. Define transforms in YAML
2. Run `gen` command
3. Check `missing_transforms.go` for stubs
4. Implement the functions in your own file
5. Re-run `gen` ‚Äî stubs are removed when real implementations exist

### Run the Example

```bash
./step9.sh
```

---

## Step 10: Nested Structs ‚Äî The Dive Hint

**Goal:** Map nested struct fields using the `dive` hint.

When you have structs inside structs, use `dive` to tell the generator to introspect:

### Source Types

```go
type Order struct {
    ID       string
    Customer Customer  // Nested struct
}

type Customer struct {
    Name  string
    Email string
}
```

### YAML with Dive

```yaml
mappings:
  - source: api.Order
    target: domain.Order
    fields:
      - source:
          Customer: dive
        target:
          Customer: dive

  # The nested type also needs a mapping
  - source: api.Customer
    target: domain.Customer
    "121":
      Name: FullName
      Email: EmailAddress
```

### When to Use Dive

- Nested structs with different field names
- Slices of structs (`[]Item`)
- Maps with struct values (`map[string]Item`)

### Run the Example

```bash
./step10.sh
```

---

## Step 11: Collections ‚Äî Slices, Arrays, and Maps

**Goal:** Map collection types with element transformation.

### Slices

```yaml
fields:
  - source:
      Items: dive      # []SourceItem
    target:
      LineItems: dive  # []TargetItem
```

### Fixed-Size Arrays

```yaml
fields:
  - source:
      Corners: dive    # [4]APIPoint
    target:
      Corners: dive    # [4]DomainPoint
```

### Maps

```yaml
fields:
  - source:
      Products: dive        # map[string]SourceProduct
    target:
      ProductIndex: dive    # map[string]TargetProduct
```

### Nested Collections

For `map[K][]V` or `[]map[K]V`:

```yaml
fields:
  - source:
      Categories: dive      # map[string][]Item
    target:
      CategoryItems: dive   # map[string][]TargetItem
```

### Run the Example

```bash
./step11.sh
```

---

## Step 12: Pointers & Deep Paths

**Goal:** Handle pointer types and access deeply nested fields.

### Automatic Pointer Handling

The generator automatically handles:
- `*T ‚Üí T` (dereference with nil check)
- `T ‚Üí *T` (wrap in pointer)
- `*T ‚Üí *T` (copy pointer or deep copy)

### Deep Source Paths

Access fields through nested structures:

```yaml
fields:
  # Extract Price from nested LineItem pointer
  - source: LineItem.Price    # deep path through *LineItem
    target: ItemPrice
```

### Generated Code

```go
// Automatic nil check for pointer paths
if in.LineItem != nil {
    out.ItemPrice = *in.LineItem.Price
}
```

### Run the Example

```bash
./step12.sh
```

---

## Step 13: Recursive Types ‚Äî Self-Referential Structs

**Goal:** Map recursive/self-referential types safely.

### Example Types

```go
// Linked list node
type Node struct {
    Value int
    Next  *Node  // Self-reference
}

type NodeDTO struct {
    Val  int
    Next *NodeDTO
}
```

### YAML Mapping

```yaml
mappings:
  - source: pkg.Node
    target: pkg.NodeDTO
    "121":
      Value: Val
    auto:
      - source: Next
        target: Next  # Recursive call
```

### Generated Code

The generator creates cycle-safe recursive calls:

```go
func NodeToNodeDTO(in Node) NodeDTO {
    out := NodeDTO{
        Val: in.Value,
    }
    if in.Next != nil {
        next := NodeToNodeDTO(*in.Next)
        out.Next = &next
    }
    return out
}
```

### Run the Example

```bash
./step13.sh
```

---

## Step 14: Context Passing ‚Äî Requires & Extra

**Goal:** Pass data from parent mappers to child mappers.

### The Problem

When mapping `Order.Items ‚Üí Order.LineItems`, each `LineItem` might need the `OrderID` from the parent `Order`.

### Solution: requires + extra

**Step 1: Declare requirement on nested type**

```yaml
- source: api.Item
  target: domain.LineItem
  requires:
    - name: OrderID
      type: uint
  fields:
    - source: OrderID      # Use the passed-in OrderID
      target: OrderID
```

**Step 2: Pass value from parent**

```yaml
- source: api.Order
  target: domain.Order
  fields:
    - source:
        Items: dive
      target:
        LineItems: dive
      extra:
        - name: OrderID
          def:
            target: OrderID  # Use already-assigned out.OrderID
```

### Generated Code

```go
// Parent caster
func APIOrderToDomainOrder(in APIOrder) DomainOrder {
    out := DomainOrder{
        OrderID: in.ID,
    }
    for _, item := range in.Items {
        out.LineItems = append(out.LineItems,
            APIItemToDomainLineItem(item, out.OrderID))  // Pass OrderID
    }
    return out
}

// Child caster with extra argument
func APIItemToDomainLineItem(in APIItem, OrderID uint) DomainLineItem {
    return DomainLineItem{
        OrderID: OrderID,  // Use passed value
        // ...
    }
}
```

### Extra Sources

`extra` can reference:
- `source: FieldName` ‚Äî from input struct
- `target: FieldName` ‚Äî from already-assigned output field
- A `requires` argument name ‚Äî passed through from parent

### Run the Example

```bash
./step14.sh
```

---

## Step 15: Virtual Types ‚Äî Generate Types On-the-Fly

**Goal:** Generate target struct definitions when they don't exist.

### Use Case

You have a source type from an external API, but no corresponding internal type yet.

### YAML with generate_target

```yaml
mappings:
  - source: external.APIResponse
    target: internal.CleanResponse
    generate_target: true    # ‚Üê Magic flag
    fields:
      - source: ID
        target: ID
      - source: RawData
        target: Data
```

### Generated Type

The generator creates `missing_types.go`:

```go
// Code generated by caster-generator. DO NOT EDIT.
package casters

type CleanResponse struct {
    ID   string
    Data []byte
}
```

### Explicit Type Control

Override inferred types:

```yaml
fields:
  - source: Value
    target: Amount
    target_type: "int64"  # Explicit type override
```

### Run the Example

```bash
./step15.sh
```

---

## Step 16: Cross-Package Virtual Types

**Goal:** Generate virtual types in a different package.

### YAML Setup

```yaml
mappings:
  - source: source_pkg.Input
    target: target_pkg.Output    # Different package!
    generate_target: true
    fields:
      - source: Data
        target: Data
```

### Command with Multiple Packages

```bash
caster-generator gen \
  -mapping mapping.yaml \
  -pkg ./source_pkg \
  -pkg ./target_pkg \
  -out ./generated
```

### Result

- `target_pkg/missing_types.go` ‚Äî Generated type definition
- `generated/casters.go` ‚Äî Generated caster functions

### Run the Example

```bash
./step16.sh
```

---

## Step 17: Check Command ‚Äî CI/CD Validation

**Goal:** Validate mappings haven't drifted from code.

### Basic Usage

```bash
caster-generator check -mapping mapping.yaml
```

### Strict Mode

```bash
# Fail if ANY target field is unmapped
caster-generator check -mapping mapping.yaml -strict
```

### CI/CD Integration

```yaml
# .github/workflows/check.yml
jobs:
  validate-mappings:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-go@v5
        with:
          go-version: '1.21'
      - run: make build
      - run: ./caster-generator check -mapping mapping.yaml -strict
```

### What It Catches

- Renamed fields in source/target structs
- Removed fields
- Type changes
- Missing transform implementations

### Run the Example

```bash
./step17.sh
```

---

## Step 18: Full Workflow ‚Äî Real-World Scenario

**Goal:** Put it all together in a complete workflow.

### The Scenario

Convert between an external API model and an internal domain model:

- `store.Order` ‚Üí `warehouse.Order`
- Handle nested `Customer`, `OrderItem` types
- Type conversions (int64 ‚Üí uint)
- Context passing (OrderID to line items)

### Complete Workflow

```bash
# 1. Analyze available types
caster-generator analyze -pkg ./store -pkg ./warehouse

# 2. Generate initial suggestions
caster-generator suggest \
  -from store.Order \
  -to warehouse.Order \
  -out mapping.yaml

# 3. Review and patch the YAML
#    - Add transforms
#    - Add ignores
#    - Add dive hints
#    - Add requires/extra

# 4. Improve suggestions with patched file
caster-generator suggest \
  -mapping mapping.yaml \
  -out mapping.yaml

# 5. Implement transform functions
#    (or let gen create stubs)

# 6. Generate caster code
caster-generator gen \
  -mapping mapping.yaml \
  -out ./generated \
  -package casters

# 7. Implement any missing transforms from stubs

# 8. Verify it compiles
go build ./generated/...

# 9. Add to CI
caster-generator check -mapping mapping.yaml -strict
```

### Run the Example

```bash
./step18.sh
```

---

## üéâ Congratulations!

You've completed the caster-generator tutorial! You now know how to:

- ‚úÖ Analyze packages and discover types
- ‚úÖ Generate mapping suggestions
- ‚úÖ Create caster code
- ‚úÖ Use `121`, `fields`, `ignore`, and `auto` sections
- ‚úÖ Handle type mismatches with transforms
- ‚úÖ Map nested structs and collections
- ‚úÖ Handle pointers and recursive types
- ‚úÖ Pass context between parent and child mappers
- ‚úÖ Generate virtual types on-the-fly
- ‚úÖ Validate mappings in CI/CD

## Quick Reference

### Commands

| Command | Purpose |
|---------|---------|
| `analyze` | Explore packages and types |
| `suggest` | Generate/improve mapping YAML |
| `gen` | Generate Go caster code |
| `check` | Validate mapping against code |

### YAML Sections (Priority Order)

| Section | Priority | Purpose |
|---------|----------|---------|
| `121` | Highest | Simple renames |
| `fields` | High | Explicit mappings |
| `ignore` | Medium | Skip target fields |
| `auto` | Lowest | Auto-matched fields |

### Environment Variables

| Variable | Purpose |
|----------|---------|
| `CG_NO_PROMPT` | Skip interactive prompts (CI) |
| `CG_DEBUG` | Show executed commands |
| `CG_VERBOSE` | More detailed output |

---

**Happy mapping! üöÄ**
